[{"/home/aureen/the_odin_project/battleship_react/src/index.js":"1","/home/aureen/the_odin_project/battleship_react/src/App.js":"2","/home/aureen/the_odin_project/battleship_react/src/components/Game.js":"3","/home/aureen/the_odin_project/battleship_react/src/components/Gameboard.js":"4","/home/aureen/the_odin_project/battleship_react/src/components/Ship.js":"5","/home/aureen/the_odin_project/battleship_react/src/data/shipsData.js":"6","/home/aureen/the_odin_project/battleship_react/src/components/Message.js":"7","/home/aureen/the_odin_project/battleship_react/src/components/Cell.js":"8","/home/aureen/the_odin_project/battleship_react/src/components/Stats.js":"9"},{"size":196,"mtime":1606237538051,"results":"10","hashOfConfig":"11"},{"size":172,"mtime":1606237538051,"results":"12","hashOfConfig":"11"},{"size":2566,"mtime":1606576500293,"results":"13","hashOfConfig":"11"},{"size":25037,"mtime":1606678974033,"results":"14","hashOfConfig":"11"},{"size":332,"mtime":1606334830651,"results":"15","hashOfConfig":"11"},{"size":320,"mtime":1606237538051,"results":"16","hashOfConfig":"11"},{"size":1321,"mtime":1606502708810,"results":"17","hashOfConfig":"11"},{"size":572,"mtime":1606334972546,"results":"18","hashOfConfig":"11"},{"size":835,"mtime":1606574806509,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"jbjmm5",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"22"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"/home/aureen/the_odin_project/battleship_react/src/index.js",[],["41","42"],"/home/aureen/the_odin_project/battleship_react/src/App.js",[],"/home/aureen/the_odin_project/battleship_react/src/components/Game.js",[],"/home/aureen/the_odin_project/battleship_react/src/components/Gameboard.js",["43","44","45","46","47","48","49"],"import React, { useState, useEffect, useRef } from 'react';\nimport Ship from './Ship';\nimport Cell from './Cell';\nimport shipsData from '../data/shipsData';\n\nfunction Gameboard({\n  size,\n  gameState,\n  player,\n  changeGameState,\n  changeCurrentPlayer,\n  currentPlayer,\n  changeLastShipSunk,\n  changePlayerStats,\n}) {\n  // -- STATE VARIABLES AND REFS --\n\n  const [board, setBoard] = useState(\n    Array(size)\n      .fill(null)\n      .map(() => Array(size).fill(null))\n  );\n\n  /* board is an array that initially contains:\n    - null if the space is empty\n    - a number (=the ship id) if it contains a ship\n    */\n\n  const [ships, setShips] = useState([\n    { id: 1 },\n    { id: 2 },\n    { id: 3 },\n    { id: 4 },\n    { id: 5 },\n  ]);\n\n  /* ships is an array that contains ship objects.\n    A ship looks something like this:\n     {\n      id: 1,\n      coordinates: {x: 0, y: 0},\n      length: 5,\n      width: 1\n     }\n    */\n\n  const [shipsChart, setShipsChart] = useState(\n    Array(size)\n      .fill(null)\n      .map(() => Array(size).fill(null))\n  );\n\n  /* shipsChart is a copy of board that only contains ships positions\n   */\n\n  const [playerStats, setPlayerStats] = useState({\n    hits: 0,\n    accuracy: 0,\n    fleet: shipsData.reduce((sum, current) => sum + +current.length, 0),\n    shipsSunk: [],\n    wins: 0,\n  });\n\n  const boardRef = useRef(null);\n  const shipsRef = [\n    useRef(null),\n    useRef(null),\n    useRef(null),\n    useRef(null),\n    useRef(null),\n  ];\n\n  // States variables used to improve computer's plays\n  const [firstHit, setFirstHit] = useState({ x: '', y: '' });\n  const [previousHit, setPreviousHit] = useState({ x: '', y: '' });\n  const [directions, setDirections] = useState([]);\n  const [previousDirection, setPreviousDirection] = useState({});\n\n  // -- FLEET PLACEMENT --\n\n  /* 1. Placing ships randomly :\n    - Generate random coordinates until available coordinates are found\n    - Update board state variable to place the ship on it\n    - Visually display the ship on its right place with useEffect.\n  */\n\n  // Generate random orientation.\n  const generateOrientation = (length) =>\n    Math.random() > 0.5 ? { length: 1, width: length } : { length, width: 1 };\n\n  // Generate random first coordinates while taking the ship's length into account.\n  // Return {x:..., y:... }.\n  const generateCoordinates = ({ length, width }) => ({\n    x: Math.floor(Math.random() * (size - length + 1)),\n    y: Math.floor(Math.random() * (size - width + 1)),\n  });\n\n  // Check if the ship can be placed on those spaces or if they are already occupied.\n  // Return true if the spaces are available, false otherwise.\n  const checkSpacesAvailability = (board, coordinates, length, width) => {\n    for (let row = coordinates.x; row < coordinates.x + length; row += 1) {\n      for (let col = coordinates.y; col < coordinates.y + width; col += 1) {\n        if (board[row][col] !== null) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  // Place one ship randomly\n  const randomPlaceShip = (board, ship) => {\n    const orientation = generateOrientation(ship.length);\n\n    let coordinates;\n    do {\n      coordinates = generateCoordinates(orientation);\n    } while (\n      !checkSpacesAvailability(\n        board,\n        coordinates,\n        orientation.length,\n        orientation.width\n      )\n    );\n\n    const placedShip = {};\n    placedShip.id = ship.id;\n    placedShip.coordinates = coordinates;\n    placedShip.length = orientation.length;\n    placedShip.width = orientation.width;\n    return placedShip;\n  };\n\n  // Loops to place all the ships randomly\n  const randomPlaceFleet = (ships) => {\n    const boardCopy = Array(size)\n      .fill(null)\n      .map(() => Array(size).fill(null));\n    const placedShips = [];\n    for (const ship of ships) {\n      const placedShip = randomPlaceShip(boardCopy, ship);\n      placedShips.push(placedShip);\n      for (\n        let { x } = placedShip.coordinates;\n        x < placedShip.coordinates.x + placedShip.length;\n        x += 1\n      ) {\n        for (\n          let { y } = placedShip.coordinates;\n          y < placedShip.coordinates.y + placedShip.width;\n          y += 1\n        ) {\n          boardCopy[x][y] = placedShip.id;\n        }\n      }\n    }\n\n    // Update board and ships states.\n    setShips(placedShips);\n    setBoard(boardCopy);\n  };\n\n  // Once the ships coordinates are determined,\n  // they are displayed on their right place on the board.\n  const displayShip = (shipElem, ship) => {\n    shipElem.current.style.gridArea = `${ship.coordinates.x + 1} / ${\n      ship.coordinates.y + 1\n    } / ${ship.coordinates.x + ship.length + 1} / ${\n      ship.coordinates.y + ship.width + 1\n    }`;\n    shipElem.current.style.flexDirection =\n      ship.length > ship.width ? 'column' : 'row';\n  };\n\n  useEffect(() => {\n    player === 1 &&\n      ships.forEach((ship, index) => {\n        if (!ship.coordinates) return;\n        displayShip(shipsRef[index], ship);\n      });\n  }, [ships]);\n\n  /* 2. Manually placing the ships.\n  Once the ships have been placed automatically at the start,\n  the user can choose to move / rotate them manually before starting the game.\n  */\n\n  // Allow players to drag their ships to place them\n  const dragOnMouseDown = (event) => {\n    // Initializing : gets ship, board position, cell size\n    if (!event.target.closest('.ship')) return;\n    const boardCoords = boardRef.current.getBoundingClientRect();\n    const cell = boardRef.current.clientWidth / size;\n    const target = event.target.closest('.ship');\n    const id = +target.id;\n    event.preventDefault();\n\n    // Prepare the ship for moving\n    shipsRef[id].current.style.zIndex = 1000;\n\n    // Remember where we click on the ship\n    const shiftX =\n      event.clientX - shipsRef[id].current.getBoundingClientRect().left;\n    const shiftY =\n      event.clientY - shipsRef[id].current.getBoundingClientRect().top;\n\n    const moveAt = (pageX, pageY) => {\n      let left = pageX - shiftX - boardCoords.left;\n      let top = pageY - shiftY - boardCoords.top;\n      shipsRef[id].current.style.gridArea = '';\n\n      // Limits draggable area to the board\n      if (left < 0) {\n        left = 0;\n      }\n\n      if (\n        left >\n        boardRef.current.clientWidth - shipsRef[id].current.offsetWidth\n      ) {\n        left = boardRef.current.clientWidth - shipsRef[id].current.offsetWidth;\n      }\n\n      if (top < 0) {\n        top = 0;\n      }\n\n      if (\n        top >\n        boardRef.current.offsetHeight - shipsRef[id].current.offsetHeight\n      ) {\n        top = boardRef.current.offsetHeight - shipsRef[id].current.offsetHeight;\n      }\n\n      shipsRef[id].current.style.left = `${left}px`;\n      shipsRef[id].current.style.top = `${top}px`;\n    };\n\n    const dragOnMouseMove = (event) => {\n      moveAt(event.pageX, event.pageY);\n    };\n\n    const dragOnMouseUp = () => {\n      // Calculate the current position\n      let coordinates = {\n        x: Math.round(\n          (shipsRef[id].current.getBoundingClientRect().top - boardCoords.top) /\n            cell\n        ),\n        y: Math.round(\n          (shipsRef[id].current.getBoundingClientRect().left -\n            boardCoords.left) /\n            cell\n        ),\n      };\n\n      // Checks if the spaces are available. If they aren't, find the next available space and place the ship there.\n      if (\n        !checkSpacesAvailability(\n          board.map((subArr) =>\n            subArr.map((cell) => (cell === id ? null : cell))\n          ),\n          coordinates,\n          ships[id].length,\n          ships[id].width\n        )\n      ) {\n        coordinates = findNextAvailableSpace(\n          board.map((subArr) =>\n            subArr.map((cell) => (cell === id ? null : cell))\n          ),\n          coordinates,\n          ships[id].length,\n          ships[id].width\n        );\n      }\n\n      // Update ships state variable and board with the new coordinates\n      const ship = Object.assign({}, ships[id]);\n      ship.coordinates = coordinates;\n\n      updateShips(ship);\n      updateBoard(ship);\n\n      // Finish dragging\n      shipsRef[id].current.style.left = '';\n      shipsRef[id].current.style.top = '';\n      shipsRef[id].current.style.zIndex = '';\n\n      document.removeEventListener('mousemove', dragOnMouseMove);\n      document.removeEventListener('mouseup', dragOnMouseUp);\n      shipsRef[id].current.onMouseDown = null;\n    };\n\n    document.addEventListener('mousemove', dragOnMouseMove);\n    document.addEventListener('mouseup', dragOnMouseUp);\n  };\n\n  // Find next available space if the player put the ship on an occupied space\n  const findNextAvailableSpace = (\n    board,\n    originalCoordinates,\n    length,\n    width\n  ) => {\n    let coordinates = originalCoordinates;\n    let radius = 1;\n\n    // Looks at all the adjacent spaces.\n    // If they are all occupied, expands the search radius and looks at the further spaces, etc.\n    while (!checkSpacesAvailability(board, coordinates, length, width)) {\n      for (let i = 0; i <= radius; i += 1) {\n        if (\n          coordinates.x - i > 0 &&\n          coordinates.y - (radius - i) > 0 &&\n          checkSpacesAvailability(\n            board,\n            { x: coordinates.x - i, y: coordinates.y - (radius - i) },\n            length,\n            width\n          )\n        ) {\n          coordinates = {\n            x: coordinates.x - i,\n            y: coordinates.y - (radius - i),\n          };\n        } else if (\n          coordinates.x - i > 0 &&\n          coordinates.y + (radius - i) < size - length &&\n          checkSpacesAvailability(\n            board,\n            { x: coordinates.x - i, y: coordinates.y + (radius - i) },\n            length,\n            width\n          )\n        ) {\n          coordinates = {\n            x: coordinates.x - i,\n            y: coordinates.y + (radius - i),\n          };\n        } else if (\n          coordinates.x + i < size - length &&\n          coordinates.y - (radius - i) > 0 &&\n          checkSpacesAvailability(\n            board,\n            { x: coordinates.x + i, y: coordinates.y - (radius - i) },\n            length,\n            width\n          )\n        ) {\n          coordinates = {\n            x: coordinates.x + i,\n            y: coordinates.y - (radius - i),\n          };\n        } else if (\n          coordinates.x + i < size - length &&\n          coordinates.y + (radius - i) < size - length &&\n          checkSpacesAvailability(\n            board,\n            { x: coordinates.x + i, y: coordinates.y + (radius - i) },\n            length,\n            width\n          )\n        ) {\n          coordinates = {\n            x: coordinates.x + i,\n            y: coordinates.y + (radius - i),\n          };\n        }\n      }\n      radius += 1;\n    }\n    return coordinates;\n  };\n\n  /* 3. Ships can be rotated on double click\n  - To rotate a ship, we swap its length and width.\n  - If swapping them causes the ship to overflow from the board, we change the coordinates to fit the board.\n  - If rotating causes the ship to overlap on another ship, we place it on the next available space.\n  */\n  const rotate = (event) => {\n    // Initializing\n    if (!event.target.closest('.ship')) return;\n    const target = event.target.closest('.ship');\n    const id = +target.id;\n\n    // Swap width and length\n    let ship = Object.assign({}, ships[id]);\n    let tempLength = ship.length;\n    ship.length = ship.width;\n    ship.width = tempLength;\n\n    // If the ship overflows from the board, its coordinate change to fit the board.\n    if (ship.coordinates.x + ship.length > size)\n      ship.coordinates.x = size - ship.length;\n    if (ship.coordinates.y + ship.width > size)\n      ship.coordinates.y = size - ship.width;\n\n    // If the ship rotated on an occupied space, it is placed on the next available space instead.\n    if (\n      !checkSpacesAvailability(\n        board.map((subArr) =>\n          subArr.map((cell) => (cell === ship.id ? null : cell))\n        ),\n        ship.coordinates,\n        ship.length,\n        ship.width\n      )\n    ) {\n      ship.coordinates = findNextAvailableSpace(\n        board.map((subArr) =>\n          subArr.map((cell) => (cell === ship.id ? null : cell))\n        ),\n        ship.coordinates,\n        ship.length,\n        ship.width\n      );\n    }\n\n    // Update ships and board state variables\n    updateShips(ship);\n    updateBoard(ship);\n  };\n\n  // Helper functions to update ships and board state variables when we move a specific ship / board.\n  const updateShips = (ship) => {\n    setShips((prevShips) =>\n      prevShips.map((prevShip) => {\n        if (prevShip.id === ship.id) {\n          return ship;\n        } else {\n          return prevShip;\n        }\n      })\n    );\n  };\n\n  const updateBoard = (ship) => {\n    setBoard((prevBoard) => {\n      const board = [...prevBoard].map((subArr) =>\n        subArr.map((cell) => (cell === ship.id ? null : cell))\n      );\n      for (\n        let x = ship.coordinates.x;\n        x < ship.coordinates.x + ship.length;\n        x += 1\n      ) {\n        for (\n          let y = ship.coordinates.y;\n          y < ship.coordinates.y + ship.width;\n          y += 1\n        ) {\n          board[x][y] = ship.id;\n        }\n      }\n      return board;\n    });\n  };\n\n  // When the game starts, the ship positions alone is saved in shipsChart\n  useEffect(() => {\n    if (gameState !== 'game') return;\n    setShipsChart(() => {\n      const chart = Array(size)\n        .fill(null)\n        .map(() => Array(size).fill(null));\n      for (let ship of ships) {\n        for (\n          let x = ship.coordinates.x;\n          x < ship.coordinates.x + ship.length;\n          x += 1\n        ) {\n          for (\n            let y = ship.coordinates.y;\n            y < ship.coordinates.y + ship.width;\n            y += 1\n          ) {\n            chart[x][y] = ship.id;\n          }\n        }\n      }\n      return chart;\n    });\n  }, [gameState]);\n\n  // -- GAME --\n\n  /* To play a turn :\n  - Get valid coordinates\n  - Play turn, mark the board, checks if a ship sunk, checks if there was a victory\n  - If there was no victory, change the player.\n  */\n\n  const playerPlay = (event) => {\n    if (\n      board[event.target.dataset.x][event.target.dataset.y] === 'X' ||\n      board[event.target.dataset.x][event.target.dataset.y] === 'O'\n    )\n      return;\n    handleTurn(event.target.dataset.x, event.target.dataset.y);\n  };\n\n  const computerEasyPlay = () => {\n    let coordinates;\n    do {\n      coordinates = generateRandomPlay();\n    } while (\n      board[coordinates.x][coordinates.y] === 'X' ||\n      board[coordinates.x][coordinates.y] === 'O'\n    );\n    // Small setTimeout to simulate \"thinking\" time.\n    setTimeout(() => handleTurn(coordinates.x, coordinates.y), 300);\n  };\n\n  const generateRandomPlay = () => {\n    return {\n      x: Math.floor(Math.random() * size),\n      y: Math.floor(Math.random() * size),\n    };\n  };\n\n  const handleTurn = (x, y) => {\n    // Nothing happens if the player choose a cell he already chose.\n    if (board[x][y] === 'X' || board[x][y] === 'O') return;\n\n    // If the cell is empty, we mark the cell as played on and move to the next turn.\n    if (board[x][y] === null) {\n      setBoard((prevBoard) => {\n        prevBoard[x][y] = 'X';\n        return prevBoard;\n      });\n    }\n\n    /* If the cell contains a ship:\n    1. The cell is marked with a 'O'\n    2. Check if the ship sunk\n    3. If it sunk, check if it was the last ship.\n    */\n\n    if (typeof board[x][y] === 'number') {\n      // Marks the cell with a 'O'\n      const currentBoard = [...board];\n      currentBoard[x][y] = 'O';\n      setBoard(currentBoard);\n\n      // Check if the ship sunk\n      // If it didn't sink, we keep on playing normally.\n      // If it sunk, we checked if there are ships left.\n      // We also announce that a ship fell.\n      if (!currentBoard.flat().includes(shipsChart[x][y])) {\n        changeLastShipSunk(player, shipsChart[x][y]);\n        // There are ships left: we go to the next turn.\n        if (\n          currentBoard.flat().filter((item) => typeof item === 'number')\n            .length === 0\n        ) {\n          changeGameState('end');\n          setPlayerStats((prevStats) => {\n            const stats = Object.assign({}, prevStats);\n            stats.wins = prevStats.wins + 1;\n            return stats;\n          });\n        }\n      }\n    }\n\n    // At the end of each turn, swap player and update stats.\n    changeCurrentPlayer();\n    setPlayerStats((prevStats) => {\n      const stats = Object.assign({}, prevStats);\n      stats.hits = prevStats.hits + 1;\n      stats.accuracy = board.flat().filter((cell) => cell === 'O').length;\n      stats.fleet =\n        shipsData.reduce((sum, current) => sum + +current.length, 0) -\n        board.flat().filter((cell) => cell === 'O').length;\n      stats.shipsSunk = Array.from(\n        new Set(\n          shipsChart.flat().filter((ship) => !board.flat().includes(ship))\n        )\n      );\n      return stats;\n    });\n  };\n\n  const computerNormalPlay = () => {\n    let coordinates;\n    let currentDirections = [...directions];\n\n    do {\n      // If the computer has no indication about a potential ship position, it just hits random spaces.\n      if (currentDirections.length === 0) {\n        coordinates = generateRandomPlay();\n\n        // Otherwise, we follow the first direction of the directions array.\n      } else {\n        if (JSON.stringify(previousHit) === JSON.stringify(firstHit)) {\n          coordinates = {\n            x: firstHit.x + currentDirections[0].x,\n            y: firstHit.y + currentDirections[0].y,\n          };\n        } else {\n          // If the computer found a ship on an adjacent space, it keeps going in the same direction.\n          if (currentDirections[0] === previousDirection) {\n            coordinates = {\n              x: previousHit.x + currentDirections[0].x,\n              y: previousHit.y + currentDirections[0].y,\n            };\n            // If the computer didn't find a ship when he went in the previous direction, it tries another adjacent space.\n          } else {\n            coordinates = {\n              x: firstHit.x + currentDirections[0].x,\n              y: firstHit.y + currentDirections[0].y,\n            };\n          }\n        }\n        if (\n          coordinates.x < 0 ||\n          coordinates.x > size ||\n          coordinates.y < 0 ||\n          coordinates.y > size ||\n          board[coordinates.x][coordinates.y] === 'X' ||\n          board[coordinates.x][coordinates.y] === 'O'\n        ) {\n          currentDirections = currentDirections.slice(1);\n        }\n      }\n    } while (\n      coordinates.x < 0 ||\n      coordinates.x > size ||\n      coordinates.y < 0 ||\n      coordinates.y > size ||\n      board[coordinates.x][coordinates.y] === 'X' ||\n      board[coordinates.x][coordinates.y] === 'O'\n    );\n    setDirections(currentDirections);\n    setPreviousDirection(currentDirections[0]);\n    handleComputerTurn(coordinates.x, coordinates.y);\n  };\n\n  const handleComputerTurn = (x, y) => {\n    // If the cell is empty:\n    // - We mark the cell as played.\n    // - If checking this cell was the result of searching adjacents spaces, we delete the direction we were searching in.\n    if (board[x][y] === null) {\n      setBoard((prevBoard) => {\n        prevBoard[x][y] = 'X';\n        return prevBoard;\n      });\n      setDirections((prevDirections) => {\n        let directions = [...prevDirections];\n        directions = directions.slice(1);\n        return directions;\n      });\n    }\n\n    /* If the cell contains a ship:\n    1. The cell is marked with a 'O'\n    2. Check if the ship sunk\n    3. If it sunk, check if it was the last ship.\n    */\n\n    if (typeof board[x][y] === 'number') {\n      // Marks the cell with a 'O'\n      const currentBoard = [...board];\n      currentBoard[x][y] = 'O';\n      setBoard(currentBoard);\n\n      // If finding the ship was the result of a random attack:\n      // - Tells the computer to remember this space\n      // - Tells the computer to search in adjacent spaces during the next few turns (top, bottom, left, right)\n      // If it was the result of searching adjacents spaces:\n      // - The computer keeps going in the same direction by remembering the direction it came from and the space it's just hit.\n      if (directions.length === 0) {\n        setFirstHit({ x, y });\n        setDirections([\n          { x: 0, y: 1 },\n          { x: 0, y: -1 },\n          { x: -1, y: 0 },\n          { x: 1, y: 0 },\n        ]);\n      }\n\n      // Check if the ship sunk\n      // If it didn't sink, we keep on playing normally.\n      // If it sunk, we check if there are ships left.\n      // We also announce that a ship fell.\n      // Tells the computer to not look in adjacent spaces anymore.\n      if (!currentBoard.flat().includes(shipsChart[x][y])) {\n        changeLastShipSunk(player, shipsChart[x][y]);\n        setDirections([]);\n        setFirstHit({ x: '', y: '' });\n        setPreviousHit({ x: '', y: '' });\n\n        // There are ships left: we go to the next turn.\n        if (\n          currentBoard.flat().filter((item) => typeof item === 'number')\n            .length === 0\n        ) {\n          changeGameState('end');\n          setPlayerStats((prevStats) => {\n            const stats = Object.assign({}, prevStats);\n            stats.wins = prevStats.wins + 1;\n            return stats;\n          });\n        }\n      }\n    }\n\n    // Remember the computer's latest hit\n    setPreviousHit({ x, y });\n\n    // At the end of each turn, swap player and update stats.\n    changeCurrentPlayer();\n    setPlayerStats((prevStats) => {\n      const stats = Object.assign({}, prevStats);\n      stats.hits = prevStats.hits + 1;\n      stats.accuracy = board.flat().filter((cell) => cell === 'O').length;\n      stats.fleet =\n        shipsData.reduce((sum, current) => sum + +current.length, 0) -\n        board.flat().filter((cell) => cell === 'O').length;\n      stats.shipsSunk = Array.from(\n        new Set(\n          shipsChart.flat().filter((ship) => !board.flat().includes(ship))\n        )\n      );\n      return stats;\n    });\n  };\n\n  // After the player plays, the computer plays.\n  // 2nd condition is added so that the computer only plays on its opponent's board.\n  useEffect(() => {\n    if (currentPlayer === 2 && player === 1) {\n      computerNormalPlay();\n    }\n  }, [currentPlayer]);\n\n  // -- GAME (RE)START --\n  // - Make player 1 the first player to play\n  // - Reset ships positions\n  // - Reset stats\n\n  // If the current player is player 2, swap it to player 1.\n  useEffect(() => {\n    if (gameState !== 'initialization') return;\n    currentPlayer === 2 && changeCurrentPlayer();\n  }, [gameState]);\n\n  // Place the ships randomly every time a new game begins.\n  useEffect(() => {\n    if (gameState !== 'initialization') return;\n    randomPlaceFleet(shipsData);\n    setShipsChart(\n      Array(size)\n        .fill(null)\n        .map(() => Array(size).fill(null))\n    );\n  }, [gameState]);\n\n  // Reset all stats except the number of wins\n  useEffect(() => {\n    if (gameState !== 'initialization') return;\n    setPlayerStats((prevStats) => {\n      const stats = Object.assign({}, prevStats);\n      stats.hits = 0;\n      stats.accuracy = 0;\n      stats.fleet = shipsData.reduce(\n        (sum, current) => sum + +current.length,\n        0\n      );\n      stats.shipsSunk = [];\n      return stats;\n    });\n  }, [gameState]);\n\n  // -- STATS --\n  // After the stats are updated, the data is sent to <Game /> to be displayed.\n  useEffect(() => {\n    changePlayerStats(playerStats);\n  }, [playerStats]);\n\n  return (\n    <div\n      className='container'\n      onMouseDown={(event) => {\n        if (gameState === 'initialization') {\n          dragOnMouseDown(event);\n        }\n      }}\n      onDoubleClick={(event) => {\n        if (gameState === 'initialization') {\n          rotate(event);\n        }\n      }}\n      ref={boardRef}\n    >\n      <div className='board'>\n        {board.map((x, xIndex) => (\n          <React.Fragment key={xIndex}>\n            {x.map((y, yIndex) => (\n              <Cell\n                key={`${xIndex}-${yIndex}`}\n                x={xIndex}\n                y={yIndex}\n                wasHit={\n                  board[xIndex][yIndex] === 'X' || board[xIndex][yIndex] === 'O'\n                }\n                containsShip={shipsChart[xIndex][yIndex] !== null}\n                isShipSunk={\n                  shipsChart[xIndex][yIndex] !== null &&\n                  !board.flat().includes(shipsChart[xIndex][yIndex])\n                }\n                playerPlay={playerPlay}\n                gameState={gameState}\n                player={player}\n              />\n            ))}\n          </React.Fragment>\n        ))}\n      </div>\n\n      {/*Ships components are only used before the game, to place the ships.*/}\n      {player === 1 &&\n        gameState === 'initialization' &&\n        shipsData.map((ship, index) => (\n          <Ship\n            length={ship.length}\n            id={ship.id}\n            key={ship.id}\n            ref={shipsRef[index]}\n          />\n        ))}\n    </div>\n  );\n}\n\nexport default Gameboard;\n","/home/aureen/the_odin_project/battleship_react/src/components/Ship.js",[],"/home/aureen/the_odin_project/battleship_react/src/data/shipsData.js",[],"/home/aureen/the_odin_project/battleship_react/src/components/Message.js",[],"/home/aureen/the_odin_project/battleship_react/src/components/Cell.js",[],["50","51"],"/home/aureen/the_odin_project/battleship_react/src/components/Stats.js",[],{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","severity":1,"message":"57","line":182,"column":6,"nodeType":"58","endLine":182,"endColumn":13,"suggestions":"59"},{"ruleId":"56","severity":1,"message":"60","line":485,"column":6,"nodeType":"58","endLine":485,"endColumn":17,"suggestions":"61"},{"ruleId":"62","severity":1,"message":"63","line":504,"column":9,"nodeType":"64","messageId":"65","endLine":504,"endColumn":25},{"ruleId":"56","severity":1,"message":"66","line":737,"column":6,"nodeType":"58","endLine":737,"endColumn":21,"suggestions":"67"},{"ruleId":"56","severity":1,"message":"68","line":748,"column":6,"nodeType":"58","endLine":748,"endColumn":17,"suggestions":"69"},{"ruleId":"56","severity":1,"message":"70","line":759,"column":6,"nodeType":"58","endLine":759,"endColumn":17,"suggestions":"71"},{"ruleId":"56","severity":1,"message":"72","line":781,"column":6,"nodeType":"58","endLine":781,"endColumn":19,"suggestions":"73"},{"ruleId":"52","replacedBy":"74"},{"ruleId":"54","replacedBy":"75"},"no-native-reassign",["76"],"no-negated-in-lhs",["77"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'player' and 'shipsRef'. Either include them or remove the dependency array.","ArrayExpression",["78"],"React Hook useEffect has missing dependencies: 'ships' and 'size'. Either include them or remove the dependency array. If 'setShipsChart' needs the current value of 'size', you can also switch to useReducer instead of useState and read 'size' in the reducer.",["79"],"no-unused-vars","'computerEasyPlay' is assigned a value but never used.","Identifier","unusedVar","React Hook useEffect has missing dependencies: 'computerNormalPlay' and 'player'. Either include them or remove the dependency array.",["80"],"React Hook useEffect has missing dependencies: 'changeCurrentPlayer' and 'currentPlayer'. Either include them or remove the dependency array. If 'changeCurrentPlayer' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["81"],"React Hook useEffect has missing dependencies: 'randomPlaceFleet' and 'size'. Either include them or remove the dependency array. If 'setShipsChart' needs the current value of 'size', you can also switch to useReducer instead of useState and read 'size' in the reducer.",["82"],"React Hook useEffect has a missing dependency: 'changePlayerStats'. Either include it or remove the dependency array. If 'changePlayerStats' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["83"],["76"],["77"],"no-global-assign","no-unsafe-negation",{"desc":"84","fix":"85"},{"desc":"86","fix":"87"},{"desc":"88","fix":"89"},{"desc":"90","fix":"91"},{"desc":"92","fix":"93"},{"desc":"94","fix":"95"},"Update the dependencies array to be: [player, ships, shipsRef]",{"range":"96","text":"97"},"Update the dependencies array to be: [gameState, ships, size]",{"range":"98","text":"99"},"Update the dependencies array to be: [computerNormalPlay, currentPlayer, player]",{"range":"100","text":"101"},"Update the dependencies array to be: [changeCurrentPlayer, currentPlayer, gameState]",{"range":"102","text":"103"},"Update the dependencies array to be: [gameState, randomPlaceFleet, size]",{"range":"104","text":"105"},"Update the dependencies array to be: [changePlayerStats, playerStats]",{"range":"106","text":"107"},[4967,4974],"[player, ships, shipsRef]",[13847,13858],"[gameState, ships, size]",[22263,22278],"[computerNormalPlay, currentPlayer, player]",[22587,22598],"[changeCurrentPlayer, currentPlayer, gameState]",[22875,22886],"[gameState, randomPlaceFleet, size]",[23479,23492],"[changePlayerStats, playerStats]"]