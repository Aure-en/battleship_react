[{"/home/aureen/the_odin_project/battleship_react/src/index.js":"1","/home/aureen/the_odin_project/battleship_react/src/App.js":"2","/home/aureen/the_odin_project/battleship_react/src/components/Game.js":"3","/home/aureen/the_odin_project/battleship_react/src/components/Gameboard.js":"4","/home/aureen/the_odin_project/battleship_react/src/components/Ship.js":"5","/home/aureen/the_odin_project/battleship_react/src/data/shipsData.js":"6","/home/aureen/the_odin_project/battleship_react/src/components/Message.js":"7","/home/aureen/the_odin_project/battleship_react/src/components/Cell.js":"8"},{"size":196,"mtime":1606237538051,"results":"9","hashOfConfig":"10"},{"size":172,"mtime":1606237538051,"results":"11","hashOfConfig":"10"},{"size":1245,"mtime":1606320761458,"results":"12","hashOfConfig":"10"},{"size":15867,"mtime":1606328136410,"results":"13","hashOfConfig":"10"},{"size":332,"mtime":1606237538051,"results":"14","hashOfConfig":"10"},{"size":320,"mtime":1606237538051,"results":"15","hashOfConfig":"10"},{"size":627,"mtime":1606316482340,"results":"16","hashOfConfig":"10"},{"size":463,"mtime":1606327590202,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"jbjmm5",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"20"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"/home/aureen/the_odin_project/battleship_react/src/index.js",[],["36","37"],"/home/aureen/the_odin_project/battleship_react/src/App.js",[],"/home/aureen/the_odin_project/battleship_react/src/components/Game.js",[],"/home/aureen/the_odin_project/battleship_react/src/components/Gameboard.js",["38","39","40"],"import React, { useState, useEffect, useRef } from 'react';\nimport Ship from './Ship';\nimport Cell from './Cell';\nimport shipsData from '../data/shipsData';\n\nfunction Gameboard({ size, gameState, player, changeGameState, changeCurrentPlayer }) {\n\n  // -- STATE VARIABLES AND REFS --\n\n  const [board, setBoard] = useState(\n    Array(size)\n      .fill(null)\n      .map(() => Array(size).fill(null))\n  );\n  \n    /* board is an array that initially contains:\n    - null if the space is empty\n    - a number (=the ship id) if it contains a ship\n    */\n  \n  const [ships, setShips] = useState([\n    { id: 1 },\n    { id: 2 },\n    { id: 3 },\n    { id: 4 },\n    { id: 5 },\n  ]);\n\n    /* ships is an array that contains ship objects.\n    A ship looks something like this:\n     {\n      id: 1,\n      coordinates: {x: 0, y: 0},\n      length: 5,\n      width: 1\n     }\n    */\n\n  const [shipsChart, setShipsChart] = useState(\n    Array(size)\n      .fill(null)\n      .map(() => Array(size).fill(null))\n  );\n\n    /* shipsChart is a copy of board that only contains ships positions\n     */\n\n  const boardRef = useRef(null);\n  const shipsRef = [\n    useRef(null),\n    useRef(null),\n    useRef(null),\n    useRef(null),\n    useRef(null),\n  ];\n\n  // -- FLEET PLACEMENT --\n\n  /* 1. Placing ships randomly :\n    - Generate random coordinates until available coordinates are found\n    - Update board state variable to place the ship on it\n    - Visually display the ship on its right place with useEffect.\n  */\n\n  // Generate random orientation.\n  const generateOrientation = (length) =>\n    Math.random() > 0.5 ? { length: 1, width: length } : { length, width: 1 };\n\n  // Generate random first coordinates while taking the ship's length into account.\n  // Return {x:..., y:... }.\n  const generateCoordinates = ({ length, width }) => ({\n    x: Math.floor(Math.random() * (size - length + 1)),\n    y: Math.floor(Math.random() * (size - width + 1)),\n  });\n\n  // Check if the ship can be placed on those spaces or if they are already occupied.\n  // Return true if the spaces are available, false otherwise.\n  const checkSpacesAvailability = (board, coordinates, length, width) => {\n    for (let row = coordinates.x; row < coordinates.x + length; row += 1) {\n      for (let col = coordinates.y; col < coordinates.y + width; col += 1) {\n        if (board[row][col] !== null) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  // Place one ship randomly\n  const randomPlaceShip = (board, ship) => {\n    const orientation = generateOrientation(ship.length);\n\n    let coordinates;\n    do {\n      coordinates = generateCoordinates(orientation);\n    } while (\n      !checkSpacesAvailability(\n        board,\n        coordinates,\n        orientation.length,\n        orientation.width\n      )\n    );\n\n    const placedShip = {};\n    placedShip.id = ship.id;\n    placedShip.coordinates = coordinates;\n    placedShip.length = orientation.length;\n    placedShip.width = orientation.width;\n    return placedShip;\n  };\n\n  // Loops to place all the ships randomly\n  const randomPlaceFleet = (board, ships) => {\n    const boardCopy = [...board];\n    const placedShips = [];\n    for (const ship of ships) {\n      const placedShip = randomPlaceShip(boardCopy, ship);\n      placedShips.push(placedShip);\n      for (\n        let { x } = placedShip.coordinates;\n        x < placedShip.coordinates.x + placedShip.length;\n        x += 1\n      ) {\n        for (\n          let { y } = placedShip.coordinates;\n          y < placedShip.coordinates.y + placedShip.width;\n          y += 1\n        ) {\n          boardCopy[x][y] = placedShip.id;\n        }\n      }\n    }\n\n    // Update board and ships states.\n    setShips(placedShips);\n    setBoard(boardCopy);\n  };\n\n  // Once the ships coordinates are determined,\n  // they are displayed on their right place on the board.\n  const displayShip = (shipElem, ship) => {\n    shipElem.current.style.gridArea = `${ship.coordinates.x + 1} / ${\n      ship.coordinates.y + 1\n    } / ${ship.coordinates.x + ship.length + 1} / ${\n      ship.coordinates.y + ship.width + 1\n    }`;\n    shipElem.current.style.flexDirection =\n      ship.length > ship.width ? 'column' : 'row';\n  };\n\n  useEffect(() => {\n    player === 1 &&\n    ships.forEach((ship, index) => {\n      if (!ship.coordinates) return;\n      displayShip(shipsRef[index], ship);\n    });\n  }, [ships]);\n\n  useEffect(() => {\n    randomPlaceFleet(board, shipsData);\n  }, []);\n\n  /* 2. Manually placing the ships.\n  Once the ships have been placed automatically at the start,\n  the user can choose to move / rotate them manually before starting the game.\n  */\n\n  // Allow players to drag their ships to place them\n  const dragOnMouseDown = (event) => {\n    // Initializing : gets ship, board position, cell size\n    if (!event.target.closest('.ship')) return;\n    const boardCoords = boardRef.current.getBoundingClientRect();\n    const cell = boardRef.current.clientWidth / size;\n    const target = event.target.closest('.ship');\n    const id = +target.id;\n    event.preventDefault();\n\n    // Prepare the ship for moving\n    shipsRef[id].current.style.zIndex = 1000;\n\n    // Remember where we click on the ship\n    const shiftX =\n      event.clientX - shipsRef[id].current.getBoundingClientRect().left;\n    const shiftY =\n      event.clientY - shipsRef[id].current.getBoundingClientRect().top;\n\n    const moveAt = (pageX, pageY) => {\n      let left = pageX - shiftX - boardCoords.left;\n      let top = pageY - shiftY - boardCoords.top;\n      shipsRef[id].current.style.gridArea = '';\n\n      // Limits draggable area to the board\n      if (left < 0) {\n        left = 0;\n      }\n\n      if (\n        left >\n        boardRef.current.clientWidth - shipsRef[id].current.offsetWidth\n      ) {\n        left = boardRef.current.clientWidth - shipsRef[id].current.offsetWidth;\n      }\n\n      if (top < 0) {\n        top = 0;\n      }\n\n      if (\n        top >\n        boardRef.current.offsetHeight - shipsRef[id].current.offsetHeight\n      ) {\n        top = boardRef.current.offsetHeight - shipsRef[id].current.offsetHeight;\n      }\n\n      shipsRef[id].current.style.left = `${left}px`;\n      shipsRef[id].current.style.top = `${top}px`;\n    };\n\n    const dragOnMouseMove = (event) => {\n      moveAt(event.pageX, event.pageY);\n    };\n\n    const dragOnMouseUp = () => {\n      // Calculate the current position\n      let coordinates = {\n        x: Math.round(\n          (shipsRef[id].current.getBoundingClientRect().top - boardCoords.top) /\n            cell\n        ),\n        y: Math.round(\n          (shipsRef[id].current.getBoundingClientRect().left -\n            boardCoords.left) /\n            cell\n        ),\n      };\n\n      // Checks if the spaces are available. If they aren't, find the next available space and place the ship there.\n      if (\n        !checkSpacesAvailability(\n          board.map((subArr) =>\n            subArr.map((cell) => (cell === id ? null : cell))\n          ),\n          coordinates,\n          ships[id].length,\n          ships[id].width\n        )\n      ) {\n        coordinates = findNextAvailableSpace(\n          board.map((subArr) =>\n            subArr.map((cell) => (cell === id ? null : cell))\n          ),\n          coordinates,\n          ships[id].length,\n          ships[id].width\n        );\n      }\n\n      // Update ships state variable and board with the new coordinates\n      const ship = Object.assign({}, ships[id]);\n      ship.coordinates = coordinates;\n\n      updateShips(ship);\n      updateBoard(ship);\n\n      // Finish dragging\n      shipsRef[id].current.style.left = '';\n      shipsRef[id].current.style.top = '';\n      shipsRef[id].current.style.zIndex = '';\n\n      document.removeEventListener('mousemove', dragOnMouseMove);\n      document.removeEventListener('mouseup', dragOnMouseUp);\n      shipsRef[id].current.onMouseDown = null;\n    };\n\n    document.addEventListener('mousemove', dragOnMouseMove);\n    document.addEventListener('mouseup', dragOnMouseUp);\n  };\n\n  // Find next available space if the player put the ship on an occupied space\n  const findNextAvailableSpace = (\n    board,\n    originalCoordinates,\n    length,\n    width\n  ) => {\n    let coordinates = originalCoordinates;\n    let radius = 1;\n\n    // Looks at all the adjacent spaces.\n    // If they are all occupied, expands the search radius and looks at the further spaces, etc.\n    while (!checkSpacesAvailability(board, coordinates, length, width)) {\n      for (let i = 0; i <= radius; i += 1) {\n        if (\n          coordinates.x - i > 0 &&\n          coordinates.y - (radius - i) > 0 &&\n          checkSpacesAvailability(\n            board,\n            { x: coordinates.x - i, y: coordinates.y - (radius - i) },\n            length,\n            width\n          )\n        ) {\n          coordinates = {\n            x: coordinates.x - i,\n            y: coordinates.y - (radius - i),\n          };\n        } else if (\n          coordinates.x - i > 0 &&\n          coordinates.y + (radius - i) < size - length &&\n          checkSpacesAvailability(\n            board,\n            { x: coordinates.x - i, y: coordinates.y + (radius - i) },\n            length,\n            width\n          )\n        ) {\n          coordinates = {\n            x: coordinates.x - i,\n            y: coordinates.y + (radius - i),\n          };\n        } else if (\n          coordinates.x + i < size - length &&\n          coordinates.y - (radius - i) > 0 &&\n          checkSpacesAvailability(\n            board,\n            { x: coordinates.x + i, y: coordinates.y - (radius - i) },\n            length,\n            width\n          )\n        ) {\n          coordinates = {\n            x: coordinates.x + i,\n            y: coordinates.y - (radius - i),\n          };\n        } else if (\n          coordinates.x + i < size - length &&\n          coordinates.y + (radius - i) < size - length &&\n          checkSpacesAvailability(\n            board,\n            { x: coordinates.x + i, y: coordinates.y + (radius - i) },\n            length,\n            width\n          )\n        ) {\n          coordinates = {\n            x: coordinates.x + i,\n            y: coordinates.y + (radius - i),\n          };\n        }\n      }\n      radius += 1;\n    }\n    return coordinates;\n  };\n\n  /* 3. Ships can be rotated on double click\n  - To rotate a ship, we swap its length and width.\n  - If swapping them causes the ship to overflow from the board, we change the coordinates to fit the board.\n  - If rotating causes the ship to overlap on another ship, we place it on the next available space.\n  */\n  const rotate = (event) => {\n    // Initializing\n    if (!event.target.closest('.ship')) return;\n    const target = event.target.closest('.ship');\n    const id = +target.id;\n\n    // Swap width and length\n    let ship = Object.assign({}, ships[id])\n    let tempLength = ship.length\n    ship.length = ship.width\n    ship.width = tempLength\n\n    // If the ship overflows from the board, its coordinate change to fit the board.\n    if (ship.coordinates.x + ship.length > size) ship.coordinates.x = size - ship.length\n    if (ship.coordinates.y + ship.width > size) ship.coordinates.y = size - ship.width\n\n    // If the ship rotated on an occupied space, it is placed on the next available space instead.\n    if (\n      !checkSpacesAvailability(\n        board.map((subArr) =>\n          subArr.map((cell) => (cell === ship.id ? null : cell))\n        ),\n        ship.coordinates,\n        ship.length,\n        ship.width\n      )\n    ) {\n      ship.coordinates = findNextAvailableSpace(\n        board.map((subArr) =>\n          subArr.map((cell) => (cell === ship.id ? null : cell))\n        ),\n        ship.coordinates,\n        ship.length,\n        ship.width\n      );\n    }\n\n    // Update ships and board state variables\n    updateShips(ship)\n    updateBoard(ship)\n\n  };\n\n  // Helper functions to update ships and board state variables when we move a specific ship / board.\n  const updateShips = (ship) => {\n    setShips(prevShips => prevShips.map(prevShip => {\n      if (prevShip.id === ship.id) {\n        return ship\n      } else {\n        return prevShip\n      }\n    }))\n  }\n\n  const updateBoard = (ship) => {\n    setBoard((prevBoard) => {\n      const board = [...prevBoard].map((subArr) =>\n        subArr.map((cell) => (cell === ship.id ? null : cell))\n      );\n      for (\n        let x = ship.coordinates.x;\n        x < ship.coordinates.x + ship.length;\n        x += 1\n      ) {\n        for (\n          let y = ship.coordinates.y;\n          y < ship.coordinates.y + ship.width;\n          y += 1\n        ) {\n          board[x][y] = ship.id;\n        }\n      }\n      return board;\n    });\n  }\n\n  // When the game starts, the ship positions alone is saved in shipsChart\n  useEffect(() => {\n    if (gameState !== 'game') return\n    setShipsChart(prevChart => {\n      const chart = [...prevChart]\n      for (let ship of ships) {\n        for (\n          let x = ship.coordinates.x;\n          x < ship.coordinates.x + ship.length;\n          x += 1\n        ) {\n          for (\n            let y = ship.coordinates.y;\n            y < ship.coordinates.y + ship.width;\n            y += 1\n          ) {\n            chart[x][y] = ship.id;\n          }\n        }\n      }\n      return chart\n    })\n  }, [gameState])\n\n  // -- GAME --\n\n  const handleTurn = (event) => {\n    const cell = event.target\n    const x = cell.dataset.x\n    const y = cell.dataset.y\n\n    // Nothing happens if the player choose a cell he already chose.\n    if (board[x][y] === 'X' || board[x][y] === 'O') return\n\n    // If the cell is empty, we mark the cell as played on and move to the next turn.\n    if (board[x][y] === null ) {\n      setBoard(prevBoard => {\n        const board = [...prevBoard];\n        board[x][y] = 'X';\n        return board;\n      })\n      changeCurrentPlayer();\n    }\n\n    /* If the cell contains a ship:\n    1. The cell is marked with a 'O'\n    2. Check if the ship sunk\n    3. If it sunk, check if it was the last ship.\n    */\n\n    if (typeof board[x][y] === 'number') {\n      // Marks the cell with a 'O'\n      const currentBoard = [...board]\n      currentBoard[x][y] = 'O'\n      setBoard(currentBoard)\n\n      // Check if the ship sunk\n      // If it sunk, check if the player won.\n      if (currentBoard.flat().includes(board[x][y])) {\n        changeCurrentPlayer();\n      }\n\n      if (!currentBoard.flat().includes(board[x][y])) {\n        // There are ships left: we go to the next turn.\n        if (currentBoard.flat().filter(item => typeof item === 'number').length !== 0) {\n          changeCurrentPlayer();\n        } else {\n          changeGameState('end')\n        }\n      }\n    }\n  }\n\n  return (\n    <div \n      className='container' \n      onMouseDown={(event) => {\n        if (gameState === 'initialization') {\n          dragOnMouseDown(event)\n        }\n      }} \n      onDoubleClick={(event) => {\n        if (gameState === 'initialization') {\n          rotate(event)\n        }\n      }} \n      ref={boardRef}\n    >\n      <div className='board'>\n        {board.map((x, xIndex) => (\n          <React.Fragment key={xIndex}>\n            {x.map((y, yIndex) => (\n              <Cell\n                key={`${xIndex}-${yIndex}`}\n                x={xIndex}\n                y={yIndex}\n                wasHit={board[xIndex][yIndex] === 'X' || board[xIndex][yIndex] === 'O'}\n                containsShip={shipsChart[xIndex][yIndex] !== null}\n                isShipSunk={shipsChart[xIndex][yIndex] !== null && !board.flat().includes(shipsChart[xIndex][yIndex])}\n                handleTurn={handleTurn}\n                gameState={gameState}\n              />\n            ))}\n          </React.Fragment>\n        ))}\n      </div>\n\n      {player === 1 &&\n      shipsData.map((ship, index) => (\n        <Ship\n          length={ship.length}\n          id={ship.id}\n          key={ship.id}\n          ref={shipsRef[index]}\n        />\n      ))}\n\n    </div>\n  );\n}\n\nexport default Gameboard;\n","/home/aureen/the_odin_project/battleship_react/src/components/Ship.js",[],"/home/aureen/the_odin_project/battleship_react/src/data/shipsData.js",[],"/home/aureen/the_odin_project/battleship_react/src/components/Message.js",[],"/home/aureen/the_odin_project/battleship_react/src/components/Cell.js",[],{"ruleId":"41","replacedBy":"42"},{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","severity":1,"message":"46","line":158,"column":6,"nodeType":"47","endLine":158,"endColumn":13,"suggestions":"48"},{"ruleId":"45","severity":1,"message":"49","line":162,"column":6,"nodeType":"47","endLine":162,"endColumn":8,"suggestions":"50"},{"ruleId":"45","severity":1,"message":"51","line":460,"column":6,"nodeType":"47","endLine":460,"endColumn":17,"suggestions":"52"},"no-native-reassign",["53"],"no-negated-in-lhs",["54"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'player' and 'shipsRef'. Either include them or remove the dependency array.","ArrayExpression",["55"],"React Hook useEffect has missing dependencies: 'board' and 'randomPlaceFleet'. Either include them or remove the dependency array.",["56"],"React Hook useEffect has a missing dependency: 'ships'. Either include it or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setShipsChart' needs the current value of 'ships'.",["57"],"no-global-assign","no-unsafe-negation",{"desc":"58","fix":"59"},{"desc":"60","fix":"61"},{"desc":"62","fix":"63"},"Update the dependencies array to be: [player, ships, shipsRef]",{"range":"64","text":"65"},"Update the dependencies array to be: [board, randomPlaceFleet]",{"range":"66","text":"67"},"Update the dependencies array to be: [gameState, ships]",{"range":"68","text":"69"},[4351,4358],"[player, ships, shipsRef]",[4427,4429],"[board, randomPlaceFleet]",[13194,13205],"[gameState, ships]"]